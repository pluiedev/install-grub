use std::{
	collections::HashSet,
	fmt::Write as _,
	fs,
	os::unix::fs::PermissionsExt,
	path::{Path, PathBuf},
	process::Command,
};

use anyhow::{anyhow, bail, Context as _, Result};
use nix::sys::stat::{umask, Mode};
use tempfile::TempDir;
use walkdir::WalkDir;

use crate::{
	config::{Config, Password, User},
	grub::Grub,
};

pub struct Builder<'conf> {
	config: &'conf Config,

	grub_boot: Grub,
	grub_store: Option<Grub>,
	grub_boot_path_normalized: PathBuf,

	default_config: PathBuf,
	pub copied: HashSet<PathBuf>,

	inner: String,
}
impl<'conf> Builder<'conf> {
	pub fn new(config: &'conf Config, default_config: PathBuf) -> Result<Self> {
		let grub = config.boot_path.join("grub");
		fs::create_dir_all(&grub)?;
		fs::set_permissions(&grub, fs::Permissions::from_mode(0o700))?;

		let grub_boot = Grub::new(&config.boot_path, config)?;
		let grub_store = if !config.copy_kernels {
			Some(Grub::new(&config.store_path, config)?)
		} else {
			None
		};

		let grub_boot_path_normalized = if grub_boot.path == Path::new("/") {
			PathBuf::new()
		} else {
			grub_boot.path.to_owned()
		};

		Ok(Self {
			config,
			grub_boot,
			grub_store,
			grub_boot_path_normalized,
			default_config,
			copied: HashSet::new(),
			inner: String::from("# Automatically generated.  DO NOT EDIT THIS FILE!\n\n"),
		})
	}

	pub fn write(&self) -> Result<(PathBuf, PathBuf)> {
		let conf_file = self.config.boot_path.join("grub/grub.cfg");
		let temp_file = self.config.boot_path.join("grub/grub.cfg.tmp");

		fs::write(&temp_file, &self.inner)?;
		Ok((conf_file, temp_file))
	}

	pub fn append_users(&mut self) -> Result<&mut Self> {
		let mut usernames = vec![];

		for User { name, password } in &self.config.users {
			match password {
				Password::Hashed(password) => {
					writeln!(&mut self.inner, "password_pbkdf2 {name} {password}")?
				}
				Password::Plain(password) => {
					writeln!(&mut self.inner, "password {name} {password}")?
				}
			}
			usernames.push(name.as_str());
		}
		if !usernames.is_empty() {
			writeln!(
				&mut self.inner,
				r#"set superusers="{}""#,
				usernames.join(" ")
			)?;
		}

		if let Some(store) = &self.grub_store {
			write!(&mut self.inner, r"    {}", store.search)?;
		}

		Ok(self)
	}

	pub fn append_default_entry(&mut self) -> Result<&mut Self> {
		// FIXME: should use grub-mkconfig.
		let default_entry = if self.config.save_default() {
			r#""${saved_entry}""#
		} else {
			&self.config.default_entry
		};
		let Config {
			timeout,
			timeout_style,
			..
		} = &self.config;

		write!(
			&mut self.inner,
			r#"
    {}
    if [ -s $prefix/grubenv ]; then
      load_env
    fi

    # ‘grub-reboot’ sets a one-time saved entry, which we process here and
    # then delete.
    if [ "${{next_entry}}" ]; then
      set default="${{next_entry}}"
      set next_entry=
      save_env next_entry
      set timeout=1
      set boot_once=true
    else
      set default={default_entry}
      set timeout={timeout}
    fi
    set timeout_style={timeout_style}

    function savedefault {{
        if [ -z "${{boot_once}}"]; then
        saved_entry="${{chosen}}"
        save_env saved_entry
        fi
    }}

    # Setup the graphics stack for bios and efi systems
    if [ "${{grub_platform}}" = "efi" ]; then
      insmod efi_gop
      insmod efi_uga
    else
      insmod vbe
    fi
  "#,
			self.grub_boot.search
		)?;

		Ok(self)
	}

	pub fn append_font(&mut self) -> Result<&mut Self> {
		let Config {
			font,
			boot_path,
			gfx_mode_efi,
			gfx_payload_efi,
			gfx_mode_bios,
			gfx_payload_bios,
			..
		} = &self.config;

		fs::copy(font, boot_path.join("converted-font.pf2")).with_context(|| {
			format!("Cannot copy {} to {}", font.display(), boot_path.display())
		})?;

		write!(
			&mut self.inner,
			r#"
    insmod font
    if loadfont "{}"/converted-font.pf2; then
      insmod gfxterm
      if [ "${{grub_platform}}" = "efi" ]; then
        set gfxmode={gfx_mode_efi}
        set gfxpayload={gfx_payload_efi}
      else
        set gfxmode={gfx_mode_bios}
        set gfxpayload={gfx_payload_bios}
      fi
      terminal_output gfxterm
    fi
  "#,
			self.grub_boot_path_normalized.display(),
		)?;

		Ok(self)
	}

	pub fn append_splash(&mut self) -> Result<&mut Self> {
		let Config {
			splash_image,
			background_color,
			boot_path,
			splash_mode,
			..
		} = &self.config;

		let Some(splash_image) = splash_image else {
			return Ok(self);
		};

		let mut target = PathBuf::from("background");

		let ext = if let Some(ext) = splash_image.extension() {
			if ext == "jpg" {
				"jpeg".into()
			} else {
				ext.to_string_lossy()
			}
		} else {
			bail!("Splash image has no extension - could not decide which module to load!");
		};

		target.set_extension(ext.as_ref());

		if let Some(background_color) = background_color {
			write!(
				&mut self.inner,
				r#"
    background_color '{background_color}'
          "#
			)?;
		}

		fs::copy(splash_image, boot_path.join(&target)).with_context(|| {
			format!(
				"Cannot copy {} to {}",
				splash_image.display(),
				boot_path.display()
			)
		})?;

		let splash_mode = splash_mode.as_ref().map_or(String::new(), |s| s.to_owned());
		write!(
			&mut self.inner,
			r#"
    insmod {ext}
    if background_image --mode '{splash_mode}' "{}"/{}; then
      set color_normal=white/black
      set color_highlight=black/white
    else
      set menu_color_normal=cyan/blue
      set menu_color_highlight=white/blue
    fi
        "#,
			self.grub_boot_path_normalized.display(),
			target.display(),
		)?;

		Ok(self)
	}

	pub fn append_theme(&mut self) -> Result<&mut Self> {
		let Config {
			boot_path, theme, ..
		} = &self.config;
		let theme_dir = boot_path.join("theme");

		if theme_dir.exists() {
			fs::remove_dir_all(&theme_dir).with_context(|| {
				format!("Cannot clean up theme folder in {}", boot_path.display())
			})?;
		}

		let Some(theme) = theme else {
			return Ok(self);
		};

		let mut modules_to_load = HashSet::new();
		let mut fonts = vec![];

		// TODO: Could be parallelized
		for entry in WalkDir::new(theme) {
			let entry = entry?;
			let relative = entry.path().strip_prefix(theme)?;

			if let Some(ext) = entry.path().extension().and_then(|e| e.to_str()) {
				match ext {
					"png" => _ = modules_to_load.insert("png"),
					"jpeg" | "jpg" => _ = modules_to_load.insert("jpeg"),
					"pf2" => fonts.push(relative.to_owned()),
					_ => {}
				}
			}

			fs::copy(entry.path(), theme_dir.join(relative))?;
		}

		for module in modules_to_load {
			write!(
				&mut self.inner,
				r#"
    insmod {module}
        "#
			)?;
		}

		write!(
			&mut self.inner,
			r#"
    # Sets theme.
    set theme="{}"/theme/theme.txt
    export theme
    # Load theme fonts, if any
        "#,
			self.grub_boot_path_normalized.display(),
		)?;

		for font in fonts {
			write!(
				&mut self.inner,
				r#"
    loadfont "{}"/theme/{}
          "#,
				self.grub_boot_path_normalized.display(),
				font.display(),
			)?;
		}

		Ok(self)
	}

	pub fn append_extra_config(&mut self) -> Result<&mut Self> {
		writeln!(&mut self.inner, "{}\n", self.config.extra_config)?;
		Ok(self)
	}

	pub fn append_default_entries(&mut self) -> Result<&mut Self> {
		let Config {
			extra_entries,
			extra_entries_before_nixos,
			entry_options,
			..
		} = &self.config;
		let extra_entries_before_nixos = *extra_entries_before_nixos;

		// extraEntries could refer to @bootRoot@, which we have to substitute
		let extra_entries =
			extra_entries.replace("@bootRoot@", &self.grub_boot.path.to_string_lossy());

		if extra_entries_before_nixos {
			writeln!(&mut self.inner, "{extra_entries}")?;
		}

		self.add_generation(
			"@distroName@",
			"",
			&self.default_config.clone(),
			&entry_options.clone(),
			true,
		)?;

		if !extra_entries_before_nixos {
			writeln!(&mut self.inner, "{extra_entries}")?;
		}

		Ok(self)
	}

	pub fn append_profiles(&mut self) -> Result<&mut Self> {
		self.add_profile(
			Path::new("/nix/var/nix/profiles/system"),
			"@distroName@ - All configurations",
		)?;

		for profile in fs::read_dir("/nix/var/nix/profiles/system-profiles")? {
			let profile = profile?;
			let file_name = profile.file_name();
			let Some(name) = file_name.to_str() else {
				continue;
			};

			if name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_') {
				self.add_profile(&profile.path(), &format!("@distroName@ - Profile '{name}'"))?;
			}
		}

		Ok(self)
	}

	pub fn append_prepare_config(&mut self) -> Result<&mut Self> {
		let extra_prepare_config = self
			.config
			.extra_prepare_config
			.replace("@bootPath@", &self.config.boot_path.to_string_lossy());

		if !extra_prepare_config.is_empty() {
			Command::new(&self.config.shell)
				.arg("-c")
				.arg(extra_prepare_config)
				.status()?;
		}

		Ok(self)
	}

	// Helpers
	fn add_profile(&mut self, profile: &Path, description: &str) -> Result<()> {
		writeln!(
			&mut self.inner,
			r#"submenu "{description}" --class submenu {{"#
		)?;

		let Some(parent) = profile.parent() else {
			bail!("Profile directory is somehow root?")
		};
		let Some(name) = profile.file_name() else {
			bail!("Huh???")
		};

		let mut links = fs::read_dir(parent)?
			.filter_map(|m| {
				let m = m.ok()?;
				let filename = m.file_name();
				let file = filename.to_string_lossy();

				file.strip_suffix("-link")
					.and_then(|s| s.strip_prefix(name.to_string_lossy().as_ref()))
					.and_then(|s| s.strip_prefix('-'))
					.and_then(|s| s.parse::<u32>().ok())
					.map(|g| (m.path(), g))
			})
			.collect::<Vec<_>>();

		// Reverse sort by generation number
		links.sort_by(|a, b| b.1.cmp(&a.1));

		for (link, gen) in links.into_iter().take(self.config.configuration_limit) {
			let Ok(version) = std::fs::read_to_string(link.join("nixos-version")) else {
				eprintln!("skipping corrupt system profile entry '{}'", link.display());
				continue;
			};
			let date = Self::generation_date_from_link(&link)?;

			self.add_generation(
				&format!("@distroName@ - Configuration {gen}"),
				&format!(" ({date} - {version})"),
				&link,
				&self.config.sub_entry_options.clone(),
				false,
			)?;
		}

		Ok(())
	}

	fn add_generation(
		&mut self,
		name: &str,
		name_suffix: &str,
		path: &Path,
		options: &str,
		current: bool,
	) -> Result<()> {
		let mut links = fs::read_dir(path.join("specialisation"))?
			.map(|d| d.map(|p| p.path()))
			.collect::<Result<Vec<_>, _>>()?;
		links.sort();

		if !current && !links.is_empty() {
			writeln!(
				&mut self.inner,
				r#"submenu \"> {name}{name_suffix}\" --class submenu {{"#
			)?;
		}

		let mut name = name.to_owned();
		if !links.is_empty() {
			name.push_str(" - Default");
		}
		name.push_str(name_suffix);

		self.add_entry(&name, path, options, current)?;

		for link in &links {
			let date = Self::generation_date_from_link(link)?;

			let version = if let Ok(version) = fs::read_to_string(link.join("nixos-version")) {
				version
			} else {
				let modules = link
					.join("kernel")
					.canonicalize()?
					.parent()
					.ok_or_else(|| anyhow!("Somehow $link/kernel doesn't have a parent"))?
					.join("lib/modules");

				let Some(version) = fs::read_dir(&modules)?.find_map(|m| {
					m.ok()
						.and_then(|p| Some(p.path().file_name()?.to_string_lossy().into_owned()))
				}) else {
					bail!("Somehow could not deduce the current NixOS version")
				};

				version
			};

			let entry_name =
				fs::read_to_string(link.join("configuration-name")).unwrap_or_else(|_| {
					format!(
						"({} - {date} - {version})",
						link.file_name().unwrap_or_default().to_string_lossy()
					)
				});

			self.add_entry(&format!("{name} - {entry_name}"), link, "", true)?;
		}

		if !current && !links.is_empty() {
			writeln!(&mut self.inner, "}}")?;
		}

		Ok(())
	}

	fn generation_date_from_link(link: &Path) -> Result<i32> {
		let metadata = fs::metadata(link)?;
		let duration = metadata.modified()?.elapsed()?;
		let duration = time::Duration::try_from(duration)?;

		Ok(duration.subsec_microseconds())
	}

	fn add_entry(
		&mut self,
		name: &str,
		path: &Path,
		options: &str,
		current: bool,
	) -> Result<&mut Self> {
		let kernel_dir = path.join("kernel");
		let initrd_dir = path.join("initrd");

		if !(kernel_dir.exists() && initrd_dir.exists()) {
			return Ok(self);
		}

		let kernel_dir = self.copy_to_kernels_dir(&kernel_dir)?;
		let initrd_dir = self.copy_to_kernels_dir(&initrd_dir)?;
		let mut secrets_dir = PathBuf::new();

		// Include second initrd with secrets
		let append_initrd_secrets = path.join("append-initrd-secrets");
		if let Ok(metadata) = fs::metadata(&append_initrd_secrets) {
			// Check if it's an executable file
			if metadata.is_file() && metadata.permissions().mode() & 0b111 != 0 {
				let canonicalized = path.canonicalize()?;
				let Some(system_name) = canonicalized.file_name().and_then(|s| s.to_str()) else {
					bail!(
						"Entry path {} somehow doesn't have a file name?",
						path.display()
					)
				};

				let kernels = self.config.boot_path.join("kernels");
				let secrets_name = format!("{system_name}-secrets");
				let initrd_secrets_path = kernels.join(&secrets_name);

				fs::create_dir(&kernels)?;
				fs::set_permissions(&kernels, PermissionsExt::from_mode(0o755))?;
				{
					// Make sure initrd is not world readable (won't work if /boot is FAT)
					let old_umask = umask(Mode::from_bits_truncate(0o137));

					let initrd_secrets_path_temp = TempDir::with_prefix(&secrets_name)?;

					let status = Command::new(&append_initrd_secrets)
						.arg(initrd_secrets_path_temp.path())
						.status()?;

					if !status.success() {
						if current {
							bail!("Failed to create initrd secrets ({status})");
						} else {
							eprintln!(
								r#"warning: failed to create initrd secrets for "{name}", an older generation"#
							);
							eprintln!(
								"note: this is normal after having removed or renamed a file in \
								 `boot.initrd.secrets`"
							);
						}
					}

					// Check whether any secrets were actually added
					if fs::metadata(&initrd_secrets_path_temp).map_or(0, |m| m.len()) > 0 {
						fs::rename(&initrd_secrets_path_temp, &initrd_secrets_path)
							.context("Failed to move initrd secrets into place")?;

						self.copied.insert(initrd_secrets_path);

						secrets_dir = self.grub_boot_path_normalized.join("kernels");
						secrets_dir.push(&secrets_name);
					}

					// Restore umask
					// Temp dir is automatically cleaned up.
					umask(old_umask);
				}
			}
		}

		// FIXME: $confName

		let kernel_params = format!(
			"init={} {}",
			path.join("init").canonicalize()?.display(),
			fs::read_to_string(path.join("kernel-params"))?
		);

		let xen = path.join("xen.gz");
		let xen = if xen.exists() {
			Some((
				self.copy_to_kernels_dir(&xen.canonicalize()?)?,
				fs::read_to_string(path.join("xen-params")).unwrap_or_default(),
			))
		} else {
			None
		};

		writeln!(&mut self.inner, r#"menuentry "{name}" {options} {{"#)?;
		if self.config.save_default() {
			writeln!(&mut self.inner, "  savedefault")?;
		}
		writeln!(&mut self.inner, "{}", self.grub_boot.search)?;
		if let Some(store) = &self.grub_store {
			writeln!(&mut self.inner, "{}", store.search)?;
		}
		if let Some(conf) = &self.config.extra_per_entry_config {
			writeln!(&mut self.inner, "  {conf}")?;
		}
		if let Some((xen, xen_params)) = xen {
			writeln!(
				&mut self.inner,
				"  multiboot {} {xen_params}",
				xen.display()
			)?;
			writeln!(
				&mut self.inner,
				"  module {} {kernel_params}",
				kernel_dir.display()
			)?;
			writeln!(
				&mut self.inner,
				"  module {} {}",
				initrd_dir.display(),
				secrets_dir.display()
			)?;
		} else {
			writeln!(
				&mut self.inner,
				"  linux {} {kernel_params}",
				kernel_dir.display()
			)?;
			writeln!(
				&mut self.inner,
				"  initrd {} {}",
				initrd_dir.display(),
				secrets_dir.display()
			)?;
		}
		writeln!(&mut self.inner, "}}\n")?;

		Ok(self)
	}

	fn copy_to_kernels_dir(&mut self, path: &Path) -> Result<PathBuf> {
		let Ok(path) = path.strip_prefix("/nix/store") else {
			bail!("Path {} is not in /nix/store!", path.display())
		};

		// GRUB store exists, which means the kernels and initrds are on the same
		// filesystem as / and /nix/store. No need to copy!
		if let Some(store) = &self.grub_store {
			return Ok(store.path.join(path));
		}

		let name = path.to_string_lossy().replace('/', "-");
		let mut dst = self.config.boot_path.join("kernels");
		dst.push(&name);

		// Don't copy the file if $dst already exists.  This means that we
		// have to create $dst atomically to prevent partially copied
		// kernels or initrd if this script is ever interrupted.
		if !dst.exists() {
			let Some(mut name) = dst.file_name().map(|s| s.to_os_string()) else {
				bail!(
					"Somehow path {} does not have a file name...? This shouldn't be possible!",
					dst.display()
				)
			};
			name.push(".tmp");
			let tmp = dst.with_file_name(name);

			fs::copy(path, &tmp)
				.with_context(|| format!("Cannot copy {} to {}", path.display(), tmp.display()))?;
			fs::rename(&tmp, &dst).with_context(|| {
				format!("Cannot rename {} to {}", path.display(), tmp.display())
			})?;
		}

		self.copied.insert(dst);
		Ok(self.grub_boot_path_normalized.join("kernels/name"))
	}
}
