mod appearance;
mod entries;
mod install;

use std::{
	collections::HashSet,
	fmt::Write as _,
	fs,
	os::unix::fs::PermissionsExt,
	path::{Path, PathBuf},
};

use anyhow::Result;

use crate::{
	config::{Config, Password},
	grub::Grub,
};

pub struct Builder<'conf> {
	config: Config<'conf>,

	grub_boot: Grub,
	grub_store: Option<Grub>,
	grub_boot_path_normalized: PathBuf,

	default_config: &'conf Path,
	pub copied: HashSet<PathBuf>,

	inner: String,
}
impl<'conf> Builder<'conf> {
	pub fn new(config: Config<'conf>, default_config: &'conf Path) -> Result<Self> {
		let grub = config.boot_path.join("grub");
		fs::create_dir_all(&grub)?;
		fs::set_permissions(&grub, fs::Permissions::from_mode(0o700))?;

		let grub_boot = Grub::new(config.boot_path, &config)?;
		let grub_store = if !config.copy_kernels {
			Some(Grub::new(config.store_path, &config)?)
		} else {
			None
		};

		let grub_boot_path_normalized = if grub_boot.path == Path::new("/") {
			PathBuf::new()
		} else {
			grub_boot.path.to_owned()
		};

		Ok(Self {
			config,
			grub_boot,
			grub_store,
			grub_boot_path_normalized,
			default_config,
			copied: HashSet::new(),
			inner: String::from("# Automatically generated.  DO NOT EDIT THIS FILE!\n\n"),
		})
	}

	pub fn users(&mut self) -> Result<&mut Self> {
		for (name, password) in self.config.users.0.iter() {
			match password {
				Password::Hashed(password) => {
					writeln!(&mut self.inner, "password_pbkdf2 {name} {password}")?
				}
				Password::Plain(password) => {
					writeln!(&mut self.inner, "password {name} {password}")?
				}
			}
		}

		let usernames = self.config.users.0.keys().copied().collect::<Vec<_>>();
		if !usernames.is_empty() {
			writeln!(
				&mut self.inner,
				r#"set superusers="{}""#,
				usernames.join(" ")
			)?;
		}

		if let Some(store) = &self.grub_store {
			write!(&mut self.inner, r"    {}", store.search)?;
		}

		Ok(self)
	}

	pub fn default_entry(&mut self) -> Result<&mut Self> {
		// FIXME: should use grub-mkconfig.
		let default_entry = if self.config.save_default() {
			r#""${saved_entry}""#
		} else {
			self.config.default_entry
		};

		let Config {
			timeout,
			timeout_style,
			..
		} = &self.config;

		write!(
			&mut self.inner,
			r#"{search}
if [ -s $prefix/grubenv ]; then
  load_env
fi

# ‘grub-reboot’ sets a one-time saved entry, which we process here and
# then delete.
if [ "${{next_entry}}" ]; then
  set default="${{next_entry}}"
  set next_entry=
  save_env next_entry
  set timeout=1
  set boot_once=true
else
  set default={default_entry}
  set timeout={timeout}
fi
set timeout_style={timeout_style}

function savedefault {{
    if [ -z "${{boot_once}}"]; then
    saved_entry="${{chosen}}"
    save_env saved_entry
    fi
}}

# Setup the graphics stack for bios and efi systems
if [ "${{grub_platform}}" = "efi" ]; then
  insmod efi_gop
  insmod efi_uga
else
  insmod vbe
fi
  "#,
			search = self.grub_boot.search
		)?;

		Ok(self)
	}
}
