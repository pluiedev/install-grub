use std::{
	ffi::OsStr,
	fs,
	io::{BufRead, BufReader},
	path::{Component, Path, PathBuf},
	process::{Command, Output},
	sync::atomic::{AtomicUsize, Ordering::SeqCst},
};

use anyhow::{bail, Context as _, Result};

use crate::{config::ConfigValue, Config};

static DRIVE_ID: AtomicUsize = AtomicUsize::new(1);

#[derive(Clone, Debug, Default)]
pub struct Grub {
	pub path: PathBuf,
	pub search: String,
}
impl Grub {
	pub fn new(dir: &Path, config: &Config) -> Result<Self> {
		let fs = Fs::new(dir)?;
		let mut path = dir.strip_prefix(&fs.mount)?.to_owned();

		let mut search = if fs.fs_type == "zfs" {
			// ZFS is completely separate logic as zpools are always identified by a label
			// or custom UUID
			todo!("ZFS confuses me")
		} else {
			// BTRFS is a special case in that we need to fix the referenced path based on
			// subvolumes
			if fs.fs_type == "btrfs" {
				if let Some(p) = Self::alter_path_for_btrfs(&fs, &path)? {
					path = p;
				}
			}
			config.fs_identifier.to_search(&fs)?
		};

		let drive_id = DRIVE_ID.fetch_add(1, SeqCst);
		if !search.is_empty() {
			search = format!("search --set=drive{drive_id} {search}");
			path = Path::new(&format!("($drive{drive_id})")).join(path);
		}

		Ok(Grub { path, search })
	}

	fn alter_path_for_btrfs(fs: &Fs, old: &Path) -> Result<Option<PathBuf>> {
		let subvol_id = {
			let Output {
				status,
				stdout: id_info,
				..
			} = Command::new("@btrfsprogs@/bin/btrfs")
				.arg("subvol")
				.arg("show")
				.arg(&fs.mount)
				.output()
				.context("Failed to execute btrfs subvol show")?;

			if !status.success() {
				bail!(
					"Failed to retrieve subvolume info for {}",
					fs.mount.display()
				);
			}

			let mut ids = id_info.lines().filter_map(|line| {
				if let Ok(l) = line {
					l.trim()
						.strip_prefix("Subvolume ID:")
						.map(|s| s.trim().to_owned())
				} else {
					None
				}
			});

			let Some(id) = ids.next() else {
				return Ok(None);
			};

			if ids.next().is_some() {
				bail!(
					"Btrfs subvol name for {} listed multiple times in mount",
					fs.mount.display()
				);
			}

			id
		};

		let path = {
			let Output {
				status,
				stdout: path_info,
				..
			} = Command::new("@btrfsprogs@/bin/btrfs")
				.arg("subvol")
				.arg("list")
				.arg(&fs.mount)
				.output()
				.context("Failed to execute btrfs subvol list")?;

			if !status.success() {
				bail!(
					"Failed to find {} subvolume info from btrfs",
					fs.mount.display()
				);
			}

			let mut paths = path_info.lines().filter_map(|line| {
				let Ok(l) = line else {
					return None;
				};

				let mut split = l.split(' ');
				if split.nth(1) != Some(&subvol_id) {
					return None;
				}

				split.skip_while(|&p| p != "path").nth(1).map(String::from)
			});

			let Some(path) = paths.next() else {
				bail!("Could not find a subvolume ID for {}", fs.mount.display())
			};

			if paths.next().is_some() {
				bail!(
					"Btrfs returned multiple paths for a single subvolume id, mountpoint {}",
					fs.mount.display()
				);
			}

			path
		};

		let mut new = Path::new("/").join(path);
		new.push(old);

		Ok(Some(new))
	}
}

#[derive(Clone, Debug, Default)]
struct Fs {
	device: PathBuf,
	fs_type: String,
	mount: PathBuf,
}
impl Fs {
	fn new(dir: &Path) -> Result<Self> {
		let mut best = Self::default();
		let mount_info = BufReader::new(fs::File::open("/proc/self/mountinfo")?);

		for line in mount_info.lines() {
			let line = line?;

			let mut fields = line.split(' ');
			let Some(mount_point) = fields.nth(4) else {
				bail!("Mount point not found in mountinfo entry: {line}")
			};
			// TODO: This is completely unused in the Perl version. Why is it here?
			let Some(_mount_options) = fields.next().map(|s| s.split(',')) else {
				bail!("Mount options not found in mountinfo entry: {line}")
			};

			// Skip the optional fields.
			let mut fields = fields.skip_while(|&field| field != "-").skip(1);

			let Some(fs_type) = fields.next() else {
				bail!("Filesystem type not found in mountinfo entry: {line}")
			};
			let Some(device) = fields.next() else {
				bail!("Device not found in mountinfo entry: {line}")
			};
			let Some(mut super_options) = fields.next().map(|s| s.split(',')) else {
				bail!("Super options not found in mountinfo entry: {line}")
			};

			// Skip the bind-mount on /nix/store.
			if mount_point == "/nix/store" && super_options.any(|s| s == "rw") {
				continue;
			}

			// Skip mountpoint generated by systemd-efi-boot-generator?
			if fs_type == "autofs" {
				continue;
			}

			// Ensure this matches the intended directory
			if !dir.starts_with(mount_point) {
				continue;
			}

			// Is this better than our current match?
			if mount_point.len() > best.mount.as_os_str().len()
			  // `is_dir` performs a stat, which can hang forever on network file systems, so
			  // we only make this call last, when it's likely that this is the mount point.
				&& Path::new(mount_point).is_dir()
			{
				best = Fs {
					device: PathBuf::from(device),
					fs_type: fs_type.to_owned(),
					mount: PathBuf::from(mount_point),
				}
			}
		}

		Ok(best)
	}
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum FsIdentifier {
	Uuid,
	Label,
	Provided,
}
impl ConfigValue for FsIdentifier {
	fn read(ctx: &libxml::xpath::Context, name: &str) -> Result<Self> {
		let s = <String as ConfigValue>::read(ctx, name)?;
		match s.as_str() {
			"uuid" => Ok(Self::Uuid),
			"label" => Ok(Self::Label),
			"provided" => Ok(Self::Provided),
			_ => bail!("Invalid FS identifier: {s}"),
		}
	}
}
impl FsIdentifier {
	fn to_flag(self) -> &'static str {
		match self {
			Self::Uuid => "--fs-uuid",
			Self::Label => "--label",
			_ => unreachable!(),
		}
	}

	fn to_search(self, fs: &Fs) -> Result<String> {
		match self {
			Self::Uuid | Self::Label => self.query_blkid(fs),
			Self::Provided => Ok(Self::provided_search(&fs.device).unwrap_or_default()),
		}
	}

	fn provided_search(device: &Path) -> Option<String> {
		// If the provided dev is identifying the partition using a label or uuid,
		// we should get the label / uuid and do a proper search
		let mut components = device.components();
		let Some(Component::RootDir) = components.next() else {
			return None;
		};

		if components.next() != Some(Component::Normal(OsStr::new("dev"))) {
			return None;
		}
		if components.next() != Some(Component::Normal(OsStr::new("disk"))) {
			return None;
		}

		let Some(Component::Normal(by)) = components.next() else {
			return None;
		};

		let ty = match by.to_str() {
			Some("by-label") => Self::Label,
			Some("by-uuid") => Self::Uuid,
			_ => return None,
		};

		Some(format!(
			"{} {}",
			ty.to_flag(),
			components.as_path().display()
		))
	}

	fn query_blkid(&self, fs: &Fs) -> Result<String> {
		// Based on the type pull in the identifier from the system
		let Output {
			status,
			stdout: dev_info,
			..
		} = Command::new("@utillinux@/bin/blkid")
			.arg("-o")
			.arg("export")
			.arg(&fs.device)
			.output()
			.context("Failed to execute blkid")?;

		if !status.success() {
			bail!(
				"Failed to get blkid info ({status}) for {} on {}",
				fs.mount.display(),
				fs.device.display(),
			);
		}

		for line in dev_info.lines() {
			let line = line?;
			let Some((key, value)) = line.split_once('=') else {
				continue;
			};
			if key.eq_ignore_ascii_case(self.to_flag()) {
				return Ok(format!("{} {value}", self.to_flag()));
			}
		}
		bail!(
			"Couldn't find a {} for {}",
			self.to_flag(),
			fs.device.display()
		);
	}
}
